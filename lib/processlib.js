// Generated by CoffeeScript 1.6.1
(function() {
  var ServiceManager, StormService, forever, fs, schema, util, validate,
    _this = this;

  forever = require('forever-monitor');

  validate = require('json-schema').validate;

  util = require('util');

  fs = require('fs');

  schema = {
    name: "service",
    type: "object",
    required: true,
    properties: {
      name: {
        type: "string",
        "required": true
      },
      binpath: {
        type: "string",
        "required": true
      },
      binname: {
        type: "string",
        "required": true
      },
      startargs: {
        type: "array",
        required: true,
        items: {
          type: "string",
          required: true
        }
      }
    }
  };

  StormService = (function() {

    function StormService(config) {
      this.name = config.name;
      this.binpath = config.binpath;
      this.binary = config.binname;
      this.startargs = config.startargs;
      this.reload = config.reload;
      this.processes = [];
    }

    StormService.prototype.add = function(proc, uuid) {
      util.log('uuid id' + uuid);
      return this.processes.push({
        id: uuid,
        fproc: proc
      });
    };

    return StormService;

  })();

  ServiceManager = (function() {

    function ServiceManager() {
      var _this = this;
      this.addService = function(service) {
        return ServiceManager.prototype.addService.apply(_this, arguments);
      };
      this.services = [];
      util.log("Service Manager constructor called");
    }

    ServiceManager.prototype.validateServiceData = function(data) {
      var result;
      result = validate(data, schema);
      if (result.valid === true) {
        util.log('valid JSON data');
        return true;
      } else {
        util.log(result);
        return false;
      }
    };

    ServiceManager.prototype.getManagedService = function(name) {
      var service, _i, _len, _ref;
      _ref = this.services;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        service = _ref[_i];
        if (service.name === name) {
          return service;
        }
      }
      util.log("managed service object for " + name + " is not available in the array");
      return new Error("service not available");
    };

    ServiceManager.prototype.addService = function(service) {
      var instance, ms;
      if (!this.validateServiceData(service)) {
        return new Error("Invalid input data");
      }
      instance = this.getManagedService(service.name);
      if (!(instance instanceof Error)) {
        util.log("service already exists in the array");
        return new Error("Service already exists");
      }
      ms = new ManagedService(service);
      if (ms) {
        return this.services.push(ms);
      }
    };

    ServiceManager.prototype.list = function() {
      var service, _i, _len, _ref, _results;
      util.log('inside list');
      _ref = this.services;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        service = _ref[_i];
        util.log(service.name);
        util.log(service.binpath);
        util.log(service.binary);
        util.log(service.startargs);
        _results.push(util.log(service.reload));
      }
      return _results;
    };

    ServiceManager.prototype.getForeverInstance = function(ms, uuid) {
      var instance, _i, _len, _ref;
      util.log('isRunning routine');
      _ref = ms.processes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        instance = _ref[_i];
        if (instance.id === uuid) {
          util.log("service " + ms.name + " for uuid " + uuid + " is present in processes array");
          return instance.fproc;
        }
      }
      util.log("service " + ms.name + " for uuid " + uuid + " is not present in processes array");
      return new Error("forever Instance not available");
    };

    ServiceManager.prototype.start = function(name, uuid, callback) {
      var args, binname, fi, fp, isexists, ms,
        _this = this;
      util.log("start:" + name);
      ms = this.getManagedService(name);
      if (ms instanceof Error) {
        return false;
      }
      fi = this.getForeverInstance(ms, uuid);
      if (!(fi instanceof Error)) {
        return false;
      }
      binname = null;
      binname = "" + ms.binpath + "/" + ms.binary;
      util.log("uThe binary absolute path is" + binname);
      isexists = fs.existsSync(binname);
      util.log("output of is existsin?" + isexists);
      if (!isexists) {
        util.log("The binary is not present in the system, result");
        return false;
      }
      args = [];
      args = ms.startargs;
      args.unshift(binname);
      util.log(args);
      fp = forever.start(args, {
        max: 10000,
        silent: false,
        spawnWith: {
          customFds: [-1, -1, -1],
          detached: false
        }
      });
      fp.on('error', function(err) {
        util.log("service returned the error." + err);
        return callback(false);
      });
      fp.on('exit', function(code) {
        util.log("program exited.. " + code);
        return callback(false);
      });
      return fp.on('start', function(data) {
        util.log("service " + name + " for uuid " + uuid + " successfully started ");
        ms.add(fp, uuid);
        return callback(true);
      });
    };

    ServiceManager.prototype.stop = function(name, uuid) {
      var fi, ms;
      util.log('stop :' + name);
      ms = this.getManagedService(name);
      if (ms instanceof Error) {
        return false;
      }
      fi = this.getForeverInstance(ms, uuid);
      if (fi instanceof Error) {
        return false;
      }
      fi.stop();
      return util.log("process stopped");
    };

    ServiceManager.prototype.restart = function(name, uuid, callback) {
      var fi, ms,
        _this = this;
      ms = this.getManagedService(name);
      if (ms instanceof Error) {
        return false;
      }
      fi = this.getForeverInstance(ms, uuid);
      if (fi instanceof Error) {
        return start(name, uuid, function(result) {
          util.log("service is not running.. hence starting");
          return callback(result);
        });
      } else {
        fi.restart();
        util.log("restareted");
        return true;
      }
    };

    ServiceManager.prototype.reload = function(name, uuid) {
      return util.log('reload is called');
    };

    return ServiceManager;

  })();

  module.exports = ServiceManager;

}).call(this);
