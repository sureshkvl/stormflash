// Generated by CoffeeScript 1.7.1
(function() {
  var StormBolt, StormData, StormFlash, StormPackage, StormPackages, StormRegistry, agent, async, config, query, storm,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Array.prototype.unique = function() {
    var key, output, value, _i, _ref, _results;
    output = {};
    for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
      output[this[key]] = this[key];
    }
    _results = [];
    for (key in output) {
      value = output[key];
      _results.push(value);
    }
    return _results;
  };

  StormData = require('stormagent').StormData;

  StormRegistry = require('stormagent').StormRegistry;

  query = require('dirty-query').query;

  async = require('async');


  /*
  
  class StormInstance extends StormData
  
      schema =
          name: "instance"
          type: "object"
          required: true
          additionalProperties: true
          properties:
              name : { type: "string", "required": true }
              id   : { type: "string", "required": false}
              path : { type: "string", "required": true }
              pid  : { type: "integer", "required" : false }
              monitor: { type: "boolean", "required" : false}
              status: { type: "string", "required": false}
              options:
                  type: "object"
                  required: false
              args:
                  type: "array"
                  required: false
                  items:
                      type: "string"
                      required: false
  
  
      constructor: (data) ->
          super null, data, schema
  
   *-----------------------------------------------------------------
  
  class StormInstances extends StormRegistry
      constructor: (filename) ->
          @on 'load', (key,val) ->
              entry = new StormInstance val
              if entry?
                  entry.saved = true
                  entry.id = key
                  @add key, entry
  
          @on 'updated', (entry) ->
              @log "Updated entry with key #{entry.id} with pid #{entry.data.pid}"
  
          super filename
  
       * get storminstance details
      get: (key) ->
          entry = super key
          return unless entry?
          if entry.data?
              entry.data.id = entry.id
              entry.data
          else
              entry
  
      discover: ->
          for key of @entries
              entry = @entries[key]
              if entry? and entry.data? and entry.data.pid?
                  if entry.data.monitor is true
                      @log "Emitting monitor for discovered pid #{entry.data.pid}"
                      entry.monitorOn = true
                      @emit "attachnMonitor", entry.data.pid, key
  
      match: (name) ->
           *@log "Dumping all entries", @entries
          for key of @entries
              entry = @entries[key]
              return unless entry? and entry.data?
              instance  = entry.data
              if (instance.name is name)
                 instance.id = entry.id
                 return instance
   */

  StormPackage = (function(_super) {
    var schema;

    __extends(StormPackage, _super);

    schema = {
      name: "package",
      type: "object",
      required: true,
      properties: {
        name: {
          type: "string",
          "required": true
        },
        id: {
          type: "string",
          "required": false
        },
        version: {
          type: "string",
          "required": true
        },
        source: {
          type: "string",
          "required": true
        },
        status: {
          type: "object",
          required: false,
          properties: {
            installed: {
              type: "boolean",
              "required": false
            },
            imported: {
              type: "boolean",
              "required": false
            }
          }
        },
        type: {
          type: "string",
          "required": false
        }
      }
    };

    function StormPackage(id, data) {
      StormPackage.__super__.constructor.call(this, id, data, schema);
    }

    return StormPackage;

  })(StormData);

  StormPackages = (function(_super) {
    __extends(StormPackages, _super);

    function StormPackages(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new StormPackage(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(key, entry);
        }
      });
      this.on('removed', function(key) {});
      StormPackages.__super__.constructor.call(this, filename);
    }

    StormPackages.prototype.get = function(key) {
      var entry;
      entry = StormPackages.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if (entry.data != null) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    StormPackages.prototype.match = function(pinfo) {
      var packages;
      this.log("Matching the package " + pinfo.name + " with db");
      packages = query(this.db, {
        name: pinfo.name,
        version: pinfo.version
      });
      if (!packages) {
        packages = query(this.db, {
          name: pinfo.name,
          version: "*"
        });
      }
      if (packages[0] != null) {
        this.log("Matched Package " + pinfo.name);
      }
      return packages[0];
    };

    StormPackages.prototype.find = function(name, version) {
      var packages;
      packages = query(this.db, {
        name: name,
        version: version
      });
      if (packages == null) {
        packages = query(this.db, {
          name: name,
          version: "*"
        });
      }
      if (packages[0] != null) {
        this.log("Found Package " + name + " ");
      }
      return packages[0];
    };

    return StormPackages;

  })(StormRegistry);

  StormBolt = require('stormbolt');

  StormFlash = (function(_super) {
    var exec, fs, path, processmgr, spm, uuid, validate;

    __extends(StormFlash, _super);

    validate = require('json-schema').validate;

    exec = require('child_process').exec;

    fs = require('fs');

    path = require('path');

    uuid = require('node-uuid');

    spm = require('./spm');

    processmgr = require('./processmgr');

    function StormFlash(config) {
      StormFlash.__super__.constructor.call(this, config);
      this["import"](module);
      fs.mkdir("" + this.config.datadir, function() {});
      fs.mkdir("" + this.config.datadir + "/plugins", function() {});
      this.services = new StormRegistry;
      this.packages = new StormPackages("" + this.config.datadir + "/packages.db");

      /*
      @instances = new StormInstances "#{@config.datadir}/instances.db"
      @instances.on 'ready', () =>
          @instances.discover()
       */
    }

    StormFlash.prototype.status = function() {
      var state;
      state = StormFlash.__super__.status.apply(this, arguments);
      state.packages = this.packages.list();
      state.services = this.services.list();
      return state;
    };

    StormFlash.prototype.run = function(config) {
      StormFlash.__super__.run.call(this, config);
      this.log('loading Storm Package Manager...');
      this.spm = new spm({
        log: this.log,
        repeatInterval: this.config.repeatInterval
      });
      this.spm.on('discovered', (function(_this) {
        return function(pkgType, pinfo) {
          var pkg, spkg;
          pkg = _this.packages.find(pinfo.name, pinfo.version);
          if (pkg == null) {
            _this.log("SPM Discovered a new package " + pinfo.name);
            spkg = new StormPackage(null, pinfo);
            spkg.data.status = {};
            return _this.packages.add(spkg.id, spkg);
          }
        };
      })(this));
      this.packages.on('added', (function(_this) {
        return function(pkginfo) {
          var err, pkg;
          if (!((pkginfo != null) || (pkginfo.data != null))) {
            return;
          }
          pkg = pkginfo.data;
          if (pkg.type === "npm" && /npm:/.test(pkg.source)) {
            try {
              _this["import"](pkg.name);
              pkginfo.data.status.imported = true;
              return pkginfo.data.status.installed = true;
            } catch (_error) {
              err = _error;
              return _this.log("Not able to import the module " + pkg.name);
            }
          } else {
            return pkginfo.data.status.installed = true;
          }
        };
      })(this));
      this.packages.on('ready', (function(_this) {
        return function() {
          _this.log("SPM started Monitoring the system for packages...");
          return _this.spm.monitor(_this.config.repeatInterval);
        };
      })(this));
      this.log('loading Storm Instance/Process Manager...');
      return this.processmgr = new processmgr();

      /*
      @processmgr.on "error", (error, key, pid) =>
           *when a process failed to start, what should be done?
          @log "Error while starting the process for key #{key} ", error
          entry = @instances.entries[key]
          if entry?
              entry.data.status = "error"
              entry.saved = true
              entry.monitorOn = false
              entry.data.pid = undefined
              @instances.update key, entry
      
      
      @processmgr.on "signal", (signal, pid, key) =>
          @log "recieved signal #{signal} from pid #{pid} with key #{key}"
          switch signal
              when "stopped", "killed", "exited"
                   *return if signal is null
                  entry = @instances.entries[key]
                  if entry? and entry.monitorOn is true
                      @log "Starting the process with #{entry.name}"
                       * process sent signal
                      @log "Sending stop signal to pid #{pid}"
                      @processmgr.stop pid, key
                      @start key, (key, pid) =>
                          if key instanceof Error
                              @log key
                              return
      
              when "error"
                  @log "Error in getting signals from process"
      
      @processmgr.on "attachError", (err, pid, key) =>
          @log 'attach error ', err, pid, key
      
          entry = @instances.entries[key]
          if entry isnt undefined and entry?
              entry.data.status = "error"
              @log "Failed to attach for pid " , pid , "Reason is ", err
      
      @processmgr.on "detachError", (err, pid, key) =>
          entry = @instances.entries[key]
          if entry isnt undefined and entry?
              entry.data.status = "error"
              @log "Failed to detach for pid " , pid , "Reason is ", err
      
      @processmgr.on "stopped", (signal, pid, key) =>
           * restart the process if entry has monitor option set
           * if stopped gracefully dont start it again
          @log "process stopped due to signal ", signal if signal?
          entry = @instances.entries[key] if key?
          if entry?
              @log "process was not running. pid expected is  ", pid , "binary name is ", entry.name if entry?
               *@processmgr.start  entry.name, entry.path, entry.args, entry.pid, key if entry? and entry.monitrOn is true
              @start  key, (key, pid) =>
                  if key instanceof Error
                      @log key
                      return
      
      @processmgr.on "attached", (result, pid, key) =>
          entry = @instances.entries[key]
          if entry?
              entry.data.status = "running|monitored"
              @log "process #{pid} with key #{key}  is attached"
      
      @instances.on "attachnMonitor", (pid, key) =>
           * need to attach and monitor it
          @log "Starting monitor on discovered pid #{pid} with key #{key}"
          @processmgr.attach pid, key
          @processmgr.monitor pid, key
      
      @processmgr.on "monitor", (pid, key) =>
          @log "Starting monitor on pid #{pid} with key #{key}"
          @processmgr.monitor pid, key
       */
    };

    StormFlash.prototype.install = function(pinfo, callback) {
      var err, pkg, spkg;
      try {
        spkg = new StormPackage(null, pinfo);
      } catch (_error) {
        err = _error;
        return callback(new Error(err));
      }
      pkg = this.packages.match(spkg.data);
      if (pkg != null) {
        this.log("Found matching package name " + pkg.name);
        return callback(pkg);
      }
      return this.spm.install(pinfo, (function(_this) {
        return function(pkg) {
          var result;
          if (pkg instanceof Error) {
            return callback(new Error(pkg));
          }
          spkg.data = pkg;
          spkg.data.status = {};
          spkg.data.status.installed = true;
          spkg.data.status.imported = false;
          result = _this.packages.add(spkg.id, spkg);
          result.data.id = result.id;
          _this.log('installed the package ', result);
          return callback(result);
        };
      })(this));
    };

    StormFlash.prototype.uninstall = function(pinfo, callback) {
      var instance, pkg;
      pkg = this.packages.match(pinfo);
      if (pkg == null) {
        return void 0;
      }
      instance = this.instances.match(pkg.name);
      if (instance != null) {
        this.processmgr.once('stop', function(key, pid) {
          this.processmgr.stop(pid, key);
          return this.instances.remove(key);
        });
        this.processmgr.emit('stop', instance.key, instance.pid);
      }
      return this.spm.uninstall(pinfo, (function(_this) {
        return function(result) {
          if (result instanceof Error) {
            return callback(new Error(result));
          }
          _this.emit('uinstalled', pkg.name, pkg.id);
          _this.packages.remove(pkg.id);
          return callback(result);
        };
      })(this));
    };

    StormFlash.prototype.update = function(module, entry, callback) {
      if (module.id) {
        return this.add(module, entry, false, (function(_this) {
          return function(res) {
            if (!(res instanceof Error)) {
              return callback(res);
            } else {
              return callback(res);
            }
          };
        })(this));
      } else {
        return callback(new Error("Could not find ID! " + id));
      }
    };

    StormFlash.prototype.invoke = function(service, callback) {
      var match, notRunning, opts, pid;
      opts = service.invocation;
      if (opts == null) {
        return callback(new Error("cannot invoke a service without valid service options"));
      }
      match = this.services.get(service.id);
      if (match != null) {
        return callback("DUPLICATE agent.invoke called for " + service.id + " from plugin!");
      }
      try {
        if (service.instance == null) {
          throw new Error("no previous server.instance provided for check");
        }
        process.kill(service.instance, 0);
      } catch (_error) {
        notRunning = _error;
        pid = this.processmgr.start(opts.name, opts.path, opts.args, opts.options, service.id);
        if (pid == null) {
          return callback(new Error("unable to invoke a new service via processmgr"));
        }
      }
      return this.processmgr.waitpid(pid, {
        test: false,
        timeout: 500
      }, (function(_this) {
        return function(err, duration) {
          if (err == null) {
            return callback(new Error("" + service.id + " stopped running after " + (duration / 1000) + " seconds!"));
          }
          _this.log("" + service.id + " has successfully started (or was previously running), verified running for at least " + (duration / 1000) + " seconds");
          _this.services.add(service.id, {
            invocation: service.invocation,
            instance: service.instance,
            running: service.isRunning
          });
          service.once('destroy', function() {
            _this.log("service.destroy called for " + service.id + " invoked with:", service.invocation);
            _this.processmgr.stop(service.instance, service.id);
            return _this.services.remove(service.id);
          });
          service.on('changed', function() {
            _this.log("service.changed called for " + service.id + " invoked with:", service.invocation);
            if (!service.isRunning) {
              return;
            }
            service.isRunning = false;
            service.isRestarting = true;
            _this.processmgr.stop(service.instance, service.id);
            return _this.processmgr.waitpid(service.instance, {
              test: false,
              timeout: 5000
            }, function(err, duration) {
              if (err != null) {
                return _this.log("" + service.id + " failed to stop in " + (duration / 1000) + " seconds... keeping things as-is");
              }
              _this.log("" + service.id + " has successfully stopped, took " + (duration / 1000) + " seconds");
              service.emit('stopped');
              opts = service.invocation;
              pid = _this.processmgr.start(opts.name, opts.path, opts.args, opts.options, service.id);
              if (pid == null) {
                service.isRestarting = false;
                return _this.log("failed to handle service.change, unable to start!");
              }
              return _this.processmgr.waitpid(pid, {
                test: false,
                timeout: 500
              }, function(err, duration) {
                if (err == null) {
                  service.isRestarting = false;
                  return _this.log("service did not start successfully after service.change!");
                }
                service.emit('running', pid);
                _this.log("" + service.id + " has successfully restarted following service.change with PID " + pid + "!");
                return process.nextTick(function() {
                  return service.isRestarting = false;
                });
              });
            });
          });
          service.emit('running', pid);
          callback(null, pid);
          if (opts.monitor) {
            return async.whilst(function() {
              return service.isReady;
            }, function(monitor) {
              var waitPid;
              waitPid = service.instance;
              return (function(waitPid) {
                _this.log("monitor: starting to watch for " + service.id + " running on PID " + service.instance + "...");
                return _this.processmgr.waitpid(waitPid, {
                  test: false,
                  timeout: -1,
                  interval: 1000
                }, function(err, duration) {
                  _this.log("monitor: " + service.id + " running on PID " + waitPid + " stopped running after " + (duration / 1000) + " seconds!");
                  if (service.isRestarting || (waitPid !== service.instance)) {
                    _this.log("monitor: ignoring since the process is in the process of re-starting, going back to monitoring...");
                    setTimeout(monitor, 1000);
                    return;
                  }
                  service.emit('stopped');
                  opts = service.invocation;
                  _this.log("monitor: " + service.id + " attempting to restart!");
                  pid = _this.processmgr.start(opts.name, opts.path, opts.args, opts.options, service.id);
                  return _this.processmgr.waitpid(pid, {
                    test: false,
                    timeout: 500
                  }, function(err, duration) {
                    if (err == null) {
                      throw new Error("service did not start successfully after monitor's attempt at a restart!");
                    }
                    service.emit('running', pid);
                    _this.log("monitor: " + service.id + " has successfully restarted with PID " + pid + "!");
                    return setTimeout(monitor, 1000);
                  });
                });
              })(waitPid);
            }, function(err) {
              return _this.log("monitor: " + service.id + " service is no longer being monitored!");
            });
          }
        };
      })(this));
    };


    /*
    start: (key, callback) ->
        entry = @instances.entries[key]
        return callback new Error "Key #{key} does not exist in DB" unless entry? and entry.data?
         *@log "Environment options to start the process : ", entry.data.options
        pid = @processmgr.start entry.data.name, entry.data.path, entry.data.args, entry.data.options, key
        return callback new Error "Not able to start the binary" unless pid?
        entry.data.pid = pid
        entry.monitorOn = true  if entry.data.monitor is true
        entry.saved = true
        @instances.update key, entry
        @processmgr.attach pid, key if entry.data.monitor is true
        callback key, pid if callback?
        @processmgr.emit "monitor", pid, key if entry.monitorOn is true
    
    
    stop: (key, callback) ->
        entry = @instances.entries[key]
        return callback new Error "No running process" unless entry? and entry.data? and entry.data.pid?
        @log "Stopping the process with pid #{entry.data.pid}"
        entry.monitorOn = false
        entry.saved = true
        @instances.update key, entry
        return @processmgr.stop entry.data.pid, key
    
    restart: (key, callback) ->
        entry = @instances.entries[key]
        entry.monitorOn = false
        status = @processmgr.stop entry.data.pid, key
        unless status instanceof Error
            async.series [(next) =>
                setTimeout next, 1000
    
            ], () =>
                entry.data.options.env.LD_LIBRARY_PATH = '/lib:/usr/lib'
                 *@log "Environment options to restart the process : ", entry.data.options
                pid = @processmgr.start entry.data.name, entry.data.path, entry.data.args, entry.data.options, key
                entry.data.pid = pid
                entry.monitorOn = true if entry.data.monitor is true
                entry.saved = true
                @instances.update key, entry
                @processmgr.attach pid, key if entry.data.monitor is true
                callback key,pid if callback?
                @processmgr.emit "monitor", pid, key if entry.monitorOn is true
     */

    StormFlash.prototype.newInstance = function(body) {
      var err;
      try {
        return new StormInstance(body);
      } catch (_error) {
        err = _error;
        return new Error(err);
      }
    };

    return StormFlash;

  })(StormBolt);


  /*
   * SINGLETON CLASS OBJECT
   */

  module.exports.StormFlash = StormFlash;

  module.exports.StormPackage = StormPackage;

  if (require.main === module) {
    config = null;
    storm = null;
    agent = new StormFlash(config);
    agent.run(storm);
    process.on('uncaughtException', (function(_this) {
      return function(err) {
        return agent.log("Caught an exception with backtrace", err.stack);
      };
    })(this));
  }

}).call(this);
