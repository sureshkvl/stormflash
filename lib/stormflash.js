// Generated by CoffeeScript 1.6.1
(function() {
  var StormBolt, StormData, StormFlash, StormInstance, StormInstances, StormPackage, StormPackages, StormRegistry, agent, config, storm,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Array.prototype.unique = function() {
    var key, output, value, _i, _ref, _results;
    output = {};
    for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
      output[this[key]] = this[key];
    }
    _results = [];
    for (key in output) {
      value = output[key];
      _results.push(value);
    }
    return _results;
  };

  StormData = require('stormagent').StormData;

  StormRegistry = require('stormagent').StormRegistry;

  StormInstance = (function(_super) {
    var schema;

    __extends(StormInstance, _super);

    schema = {
      name: "instance",
      type: "object",
      required: true,
      properties: {
        name: {
          type: "string",
          "required": true
        },
        id: {
          type: "string",
          "required": false
        },
        path: {
          type: "string",
          "required": true
        },
        pid: {
          type: "integer",
          "required": false
        },
        monitorOn: {
          type: "boolean",
          "required": false
        },
        args: {
          type: "array",
          required: false,
          items: {
            type: "string",
            required: false
          }
        }
      }
    };

    function StormInstance(id, data) {
      StormInstance.__super__.constructor.call(this, id, data, schema);
    }

    return StormInstance;

  })(StormData);

  StormInstances = (function(_super) {

    __extends(StormInstances, _super);

    function StormInstances(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new StormInstance(key, val);
        if (entry != null) {
          entry.saved = true;
          this.add(key, entry);
          return this.emit('instanceloaded', key, val);
        }
      });
      this.on('removed', function(key) {});
      StormInstances.__super__.constructor.call(this, filename);
    }

    StormInstances.prototype.get = function(key) {
      var entry;
      entry = StormInstances.__super__.get.call(this, key);
      return entry;
    };

    return StormInstances;

  })(StormRegistry);

  StormPackage = (function(_super) {
    var schema;

    __extends(StormPackage, _super);

    schema = {
      name: "package",
      type: "object",
      required: true,
      properties: {
        name: {
          type: "string",
          "required": true
        },
        id: {
          type: "string",
          "required": false
        },
        version: {
          type: "string",
          "required": true
        },
        source: {
          type: "string",
          "required": true
        },
        status: {
          type: "string",
          "required": false
        }
      }
    };

    function StormPackage(id, data) {
      StormPackage.__super__.constructor.call(this, id, data, schema);
    }

    return StormPackage;

  })(StormData);

  StormPackages = (function(_super) {

    __extends(StormPackages, _super);

    function StormPackages(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new StormPackage(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(key, entry);
        }
      });
      this.on('removed', function(key) {});
      StormPackages.__super__.constructor.call(this, filename);
    }

    StormPackages.prototype.get = function(key) {
      var entry;
      entry = StormPackages.__super__.get.call(this, key);
      return entry;
    };

    StormPackages.prototype.match = function(pinfo) {
      var entry, key;
      for (key in this.entries) {
        entry = this.entries[key];
        this.log("Dumping entry", entry.key, entry.value);
        if ((entry.data.name === pinfo.name) && (entry.data.version === pinfo.version) && (entry.data.source === pinfo.source)) {
          this.log("Matching entry found ", entry.data);
          entry.data.id = entry.id;
          return entry.data;
        }
      }
    };

    StormPackages.prototype.find = function(name, version) {
      var entry, key, _results;
      _results = [];
      for (key in this.entries) {
        entry = this.entries[key];
        if ((entry.data.name === name) && (entry.data.version === version)) {
          entry.data.id = entry.id;
          _results.push(entry.data);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return StormPackages;

  })(StormRegistry);

  StormBolt = require('stormbolt');

  StormFlash = (function(_super) {
    var exec, fs, path, uuid, validate;

    __extends(StormFlash, _super);

    validate = require('json-schema').validate;

    exec = require('child_process').exec;

    fs = require('fs');

    path = require('path');

    uuid = require('node-uuid');

    function StormFlash(config) {
      var processmgr, spm,
        _this = this;
      StormFlash.__super__.constructor.call(this, config);
      this["import"](module);
      this.packages = new StormPackages("" + this.config.datadir + "/packages.db");
      this.instances = new StormInstances("" + this.config.datadir + "/instances.db");
      this.log('loading spm...');
      spm = require('./spm').StormPackageManager;
      this.spm = new spm();
      this.spm.on('discover', function(pinfo) {
        var pkg;
        pkg = this.packages.find(pinfo.name(pinfo.version));
        if (pkg == null) {
          return this.packages.add(uuid.v4(), pinfo);
        }
      });
      processmgr = require('./processmgr').ProcessManager;
      this.processmgr = new processmgr();
      this.processmgr.on("error", function(error, key, pid) {
        _this.log("Error while starting the process for key " + key + " ", error);
        return entry.status = "error";
      });
      this.processmgr.on("signal", function(signal, pid, key) {
        var entry;
        _this.log("recieved signal " + signal + " from pid " + pid + " with key " + key);
        switch (signal) {
          case "stopped":
          case "killed":
          case "exited":
            if (signal === null) {
              return;
            }
            entry = _this.instances.entries[key];
            if ((entry != null) && entry.monitorOn === true) {
              _this.log("Starting the process with " + entry.name);
              _this.log("Sending stop signal to pid " + pid);
              _this.processmgr.stop(pid, key);
              return _this.start(key, function(key, pid) {
                if (key instanceof Error) {
                  _this.log(key);
                }
              });
            }
            break;
          case "error":
            return _this.log("Error in getting signals from process");
        }
      });
      this.processmgr.on("attachError", function(err, pid, key) {
        var entry;
        console.log('attach error ', err, pid, key);
        entry = _this.instances.entries[key];
        if (entry !== void 0 && (entry != null)) {
          entry.status = "error";
          return _this.log("Failed to attach for pid ", pid, "Reason is ", err);
        }
      });
      this.processmgr.on("detachError", function(err, pid, key) {
        var entry;
        entry = _this.instances.entries[key];
        if (entry !== void 0 && (entry != null)) {
          entry.status = "error";
          return _this.log("Failed to detach for pid ", pid, "Reason is ", err);
        }
      });
      this.processmgr.on("stopped", function(signal, pid, key) {
        var entry;
        if (signal != null) {
          _this.log("process stopped due to signal ", signal);
        }
        if (key != null) {
          entry = _this.instances.entries[key];
        }
        if (entry != null) {
          if (entry != null) {
            _this.log("process was not running. pid expected is  ", pid, "binary name is ", entry.name);
          }
          return _this.start(key, function(key, pid) {
            if (key instanceof Error) {
              _this.log(key);
            }
          });
        }
      });
      this.processmgr.on("attached", function(result, pid, key) {
        var entry;
        entry = _this.instances.entries[key];
        if (entry != null) {
          entry.status = "running|monitored";
          return _this.log("process " + pid + " with key " + key + "  is attached");
        }
      });
      this.processmgr.on("monitor", function(pid, key) {
        _this.log("Starting monitor on pid " + pid + " with key " + key);
        return _this.processmgr.monitor(pid, key);
      });
    }

    StormFlash.prototype.status = function() {
      var state;
      state = {};
      state.packages = this.packages.list();
      state.instances = this.instances.list();
      return state;
    };

    StormFlash.prototype.run = function(config) {
      /*
      if config?
          @log 'run called with:', config
          res = validate config, schema
          @log 'run - validation of runtime config:', res
          @config = extend(@config, config) if res.valid
      */
      StormFlash.__super__.run.call(this, config);
      return this.spm.monitor(this.config.repeatdelay);
    };

    StormFlash.prototype.install = function(pinfo, callback) {
      var pkg,
        _this = this;
      console.log(pinfo);
      this.log("checking for package " + pinfo.name + " in DB", pinfo);
      pkg = this.packages.match(pinfo);
      console.log("pkg is ", pkg);
      if (pkg != null) {
        this.log("Found matching package name " + pkg.name);
        return callback(409);
      }
      return this.spm.install(pinfo, function(pkg) {
        if (pkg instanceof Error) {
          return callback(pkg);
        }
        _this.packages.add(uuid.v4(), pinfo);
        _this.emit('installed the package ', pinfo.name, pinfo.id);
        return callback(pkg);
      });
    };

    StormFlash.prototype.uninstall = function(pinfo, callback) {
      var instance, pkg,
        _this = this;
      pkg = this.packages.match(pinfo);
      if (pkg instanceof Error) {
        return 404;
      }
      instance = this.instances.match(pkg.name);
      if (instance != null) {
        this.processmgr.once('stop', function(key, pid) {
          this.processmgr.stop(pid, key);
          return this.instances.remove(key);
        });
        this.processmgr.emit('stop', instance.key, instance.pid);
      }
      return this.spm.uninstall(pinfo, function(result) {
        if (result instanceof Error) {
          return callback(500);
        }
        _this.packages.remove(pkg.id);
        _this.emit('uinstalled', pkg.name, pkg.id);
        return callback(result);
      });
    };

    StormFlash.prototype.update = function(module, entry, callback) {
      var _this = this;
      if (module.id) {
        return this.add(module, entry, false, function(res) {
          if (!(res instanceof Error)) {
            return callback(res);
          } else {
            return callback(res);
          }
        });
      } else {
        return callback(new Error("Could not find ID! " + id));
      }
    };

    StormFlash.prototype.start = function(key, callback) {
      var entry, pid;
      entry = this.instances.get(key);
      if (entry == null) {
        return callback(new Error("Key " + key + " does not exist in DB"));
      }
      pid = this.processmgr.start(entry.name, entry.path, entry.args, key);
      if (pid == null) {
        callback(new Error("Not able to start the binary"));
      }
      entry.pid = pid;
      if (entry.monitor === true) {
        entry.monitorOn = true;
      }
      this.processmgr.attach(pid, key);
      if (callback != null) {
        callback(key, pid);
      }
      if (entry.monitorOn === true) {
        return this.processmgr.emit("monitor", pid, key);
      }
    };

    StormFlash.prototype.stop = function(key, callback) {
      var entry;
      entry = this.instances.get(key);
      if (!((entry != null) && (entry.pid != null))) {
        return callback(new Error("No running process"));
      }
      this.log("Stopping the process with pid " + entry.pid);
      entry.monitorOn = false;
      return this.processmgr.stop(entry.pid, key);
    };

    StormFlash.prototype.restart = function(key, callback) {
      var entry, pid, status;
      entry = this.instances.get(key);
      entry.monitorOn = false;
      status = this.processmgr.stop(entry.pid, key);
      if (!(status instanceof Error)) {
        pid = this.processmgr.start(entry.name, entry.path, entry.args, key);
        entry.pid = pid;
        if (entry.monitor === true) {
          return entry.monitorOn = true;
        }
      }
    };

    return StormFlash;

  })(StormBolt);

  /*
  # SINGLETON CLASS OBJECT
  */


  module.exports = StormFlash;

  module.exports.StormPackage = StormPackage;

  if (require.main === module) {
    /* 
    argv = require('minimist')(process.argv.slice(2))
    if argv.h?
        console.log """ 
            -h view this help
            -p port number
            -l logfile
            -d datadir
        """ 
        return
    
    config = {}
    config.port    = argv.p ? 5000
    config.logfile = argv.l ? "/var/log/stormflash.log"
    config.datadir = argv.d ? "/var/stormstack"
    
    storm = config.storm
    
    # COMMENT OUT below "storm" object FOR REAL USE 
    # test storm data for manual config
    # storm = null <-- should be the default
    storm =
        provider: "openstack"
        tracker: "https://allow@stormtracker.dev.intercloud.net"
        skey: "some-secure-serial-key"
        id: "testing-uuid"
        bolt:
            cert: ""
            key: ""
            ca: ""
            uplinks: [ "bolt://stormtower.dev.intercloud.net" ]
            uplinkStrategy: "round-robin"
            allowRelay: true
            relayPort: 8017
            allowedPorts: [ 5000 ]
            listenPort: 443 
            beaconInterval: 10
            beaconRetry: 3
    */

    config = null;
    storm = null;
    agent = new StormFlash(config);
    agent.run(storm);
    if (typeof gc !== "undefined" && gc !== null) {
      setInterval((function() {
        return gc();
      }), 2000);
    }
  }

}).call(this);
