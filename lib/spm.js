// Generated by CoffeeScript 1.6.1
(function() {
  var EventEmitter, StormPackageManager, fs, os,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  os = require('os');

  fs = require('fs');

  StormPackageManager = (function(_super) {
    var _defaultInstaller, _defaultPkgMgr, _discoverEnvironment;

    __extends(StormPackageManager, _super);

    _defaultInstaller = 'dpkg';

    _defaultPkgMgr = 'apt-get';

    _discoverEnvironment = function(callback) {
      var env,
        _this = this;
      switch (process.platform) {
        case "linux":
          env = {
            type: os.type(),
            platform: os.platform(),
            arch: os.arch(),
            nodeVersion: process.version
          };
          return fs.readFile("/proc/version", function(err, data) {
            var match;
            if (err != null) {
              throw err;
            }
            match = /ubuntu/i.test(data);
            if (match != null) {
              _this.installer = 'dpkg';
              _this.pkgmgr = 'apt-get';
            } else {
              _this.installer = 'rpm';
              _this.pkgmgr = 'yum';
            }
            return callback(env);
          });
        default:
          console.log("unsupported platform");
          return new Error("Unsupported Platform " + process.platform);
      }
    };

    function StormPackageManager() {
      var _this = this;
      this.installer = void 0;
      this.pkgmgr = void 0;
      this.env = {};
      _discoverEnvironment(function(env) {
        _this.env = env;
        if (env instanceof Error) {
          throw env;
        }
        return console.log('discovered environment', _this.env);
      });
    }

    StormPackageManager.prototype.monitor = function() {
      return console.log("hello");
    };

    StormPackageManager.prototype.getCommand = function(installer, command, component, filename) {
      console.log("Building command for " + installer + "." + command);
      switch ("" + installer + "." + command) {
        case "dpkg.check":
          return "dpkg -l | grep -w \"" + component.name + " \" | grep -w \"" + component.version + " \"";
        case "npm.check":
          return "cd /lib; npm ls 2>/dev/null | grep " + component.name + "@" + component.version;
        case "npm.install":
          if (!filename) {
            return "npm install " + component.name + "@" + component.version;
          }
          return "npm install " + filename;
        case "dpkg.install":
          return "dpkg -i " + filename;
        case "apt-get.install":
          return "apt-get install " + filename;
        case "dpkg.uninstall":
        case "apt-get.uninstall":
          return "dpkg -r " + filename;
        default:
          console.log(new Error("invalid command " + installer + "." + command + " for " + component.name + "!"));
          return null;
      }
    };

    StormPackageManager.prototype.check = function(installer, component, callback) {
      var command,
        _this = this;
      console.log("checking if the component '" + component.name + "' has already been installed using " + installer + "...");
      switch (installer) {
        case "npm:":
          command = this.getCommand('npm', 'check', component);
          break;
        case "dpkg:":
        case "apt-get:":
          command = this.getCommand('dpkg', 'check', component);
          break;
        default:
          return callback(new Error("Unsupported installer " + installer));
      }
      return this.execute(command, function(error) {
        if (!(error instanceof Error)) {
          console.log("" + component.name + " is already installed");
          return callback(true);
        } else {
          return callback(error);
        }
      });
    };

    StormPackageManager.prototype.execute = function(command, callback) {
      var exec,
        _this = this;
      exec = require('child_process').exec;
      console.log('executing the command ', command);
      return exec("" + command, function(error, stdout, stderr) {
        if (error != null) {
          return callback(new Error(error));
        }
        return callback(stdout);
      });
    };

    StormPackageManager.prototype.install = function(pinfo, callback) {
      var cmd, filename, parsedurl, source, url, webreq,
        _this = this;
      if (!((pinfo.name != null) && (pinfo.version != null) && (pinfo.source != null))) {
        return new Error("Invalid parameters");
      }
      url = require('url');
      if (pinfo.source != null) {
        parsedurl = url.parse(pinfo.source, true);
        console.log('the protocol for the package download is ', parsedurl.protocol);
      }
      this.check(parsedurl.protocol, pinfo, function(pkg) {
        if (!(pkg instanceof Error)) {
          console.log("Found the component installed ", pinfo.name);
          return callback(pinfo);
        }
      });
      switch (parsedurl.protocol) {
        case 'npm:':
          if (parsedurl.path) {
            parsedurl.protocol = "http";
            filename = url.format(parsedurl);
            cmd = this.getCommand("npm", "install", pinfo, filename);
          } else {
            cmd = this.getCommand("npm", "install", pinfo);
          }
          break;
        case "dpkg:":
          if (pinfo.source == null) {
            return callback(new Error("Must specify source"));
          }
          parsedurl.protocol = "http";
          webreq = require('request');
          fs = require('fs');
          filename = "/tmp/" + pinfo.name + ".pkg";
          source = url.format(parsedurl);
          webreq(source, function(error, response, body) {
            if (error != null) {
              return new Error("unable to download file");
            }
            if (fs.existsSync(filename)) {
              cmd = _this.getCommand("dpkg", "install", pinfo, filename);
              if (cmd == null) {
                return callback(new Error("Unable to install package install"));
              }
              return _this.execute(cmd, function(result) {
                if (result instanceof Error) {
                  return callback(result);
                }
                return callback(pinfo);
              });
            } else {
              return callback(new Error("unable to download package"));
            }
          }).pipe(fs.createWriteStream(filename));
          return;
        case "apt-get:":
          cmd = this.getCommand("apt-get", "install", pinfo, "" + pinfo.name + "-" + pinfo.version);
          break;
        default:
          return callback(new Error("Unsupported package manager"));
      }
      try {
        return this.execute(cmd, function(result) {
          return callback(result);
        });
      } catch (err) {
        return callback(new Error("Failed to install"));
      }
    };

    StormPackageManager.prototype.uninstall = function(pinfo, callback) {
      var cmd, parsedurl, url,
        _this = this;
      if (pinfo.source === ("builtin" != null)) {
        return callback(new Error("Should not uninstall built in package"));
      }
      url = require('url');
      if (pinfo.source != null) {
        parsedurl = url.parse(pinfo.source, true);
        if (parsedurl == null) {
          return callback(new Error("Cannot parse the package source"));
        }
        switch (parsedurl.protocol) {
          case "npm:":
            cmd = this.getCommand("npm", "uninstall", pinfo);
            break;
          case "dpkg:":
          case "apt-get:":
            cmd = this.getCommand("dpkg", "uninstall", pinfo);
            break;
          default:
            return callback(new Error("Unsupported uninstall protocol"));
        }
        return this.execute(cmd, function(result) {
          if (result instanceof Error) {
            return callback(result);
          }
          return callback("Success");
        });
      }
    };

    return StormPackageManager;

  })(EventEmitter);

  module.exports.StormPackageManager = StormPackageManager;

}).call(this);
