// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, StormPackageManager, async, exec, fs, os,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  os = require('os');

  fs = require('fs');

  async = require('async');

  exec = require('child_process').exec;

  StormPackageManager = (function(_super) {
    var _defaultInstaller, _defaultPkgMgr, _discoverDebPkgs, _discoverEnvironment, _discoverNpmModules;

    __extends(StormPackageManager, _super);

    _defaultInstaller = 'dpkg';

    _defaultPkgMgr = 'apt-get';

    _discoverNpmModules = function(callback) {
      return exec("npm ls --json --depth=0", (function(_this) {
        return function(error, stdout, stderr) {
          if (stdout) {
            return callback(stdout);
          }
        };
      })(this));
    };

    _discoverDebPkgs = function(callback) {
      return exec("dpkg -l | tail -n+6", (function(_this) {
        return function(error, stdout, stderr) {
          if (stdout) {
            return callback(stdout);
          }
        };
      })(this));
    };

    _discoverEnvironment = function(callback) {
      var env;
      switch (process.platform) {
        case "linux":
          env = {
            type: os.type(),
            platform: os.platform(),
            arch: os.arch(),
            nodeVersion: process.version
          };
          return fs.readFile("/proc/version", (function(_this) {
            return function(err, data) {
              var match;
              if (err != null) {
                throw err;
              }
              match = /ubuntu/i.test(data);
              if (match != null) {
                _this.installer = 'dpkg';
                _this.pkgmgr = 'apt-get';
              } else {
                _this.installer = 'rpm';
                _this.pkgmgr = 'yum';
              }
              return callback(env);
            };
          })(this));
        default:
          this.log("unsupported platform");
          return new Error("Unsupported Platform " + process.platform);
      }
    };

    function StormPackageManager(context) {
      this.installer = void 0;
      this.pkgmgr = void 0;
      this.env = {};
      this.npmPackages = {};
      this.debPackages = {};
      if (context != null) {
        this.repeatInterval = context.repeatInterval;
        this.log = context.log;
      }
      if (this.repeatInterval == null) {
        this.repeatInterval = 8000;
      }
      if (this.log == null) {
        this.log = console.log;
      }
      _discoverEnvironment((function(_this) {
        return function(env) {
          _this.env = env;
          if (env instanceof Error) {
            throw env;
          }
          return _this.log('discovered environment', _this.env);
        };
      })(this));
    }

    StormPackageManager.prototype.monitorDebPkgs = function(callback) {
      this.log("searching for debian packages");
      return _discoverDebPkgs((function(_this) {
        return function(content) {
          if (content == null) {
            return callback("success");
          }
          _this.analyzeDeb(content, 0);
          return callback("success");
        };
      })(this));
    };

    StormPackageManager.prototype.analyzeDeb = function(content, firstime) {
      var contents, pkg, result, _i, _len, _results;
      if (content != null) {
        contents = content.split(/[ ,]+/).join(',').split('ii');
        _results = [];
        for (_i = 0, _len = contents.length; _i < _len; _i++) {
          pkg = contents[_i];
          content = pkg.split(',');
          if ((content[1] != null) && (content[2] != null)) {
            result = {
              name: content[1],
              version: content[2],
              source: "builtin",
              type: "dpkg"
            };
            if (firstime) {
              _results.push(this.debPackages[result.name] = result.version);
            } else {
              if (this.debPackages[content[1]] == null) {
                this.emit('discovered', "deb", result);
              }
              _results.push(this.debPackages[result.name] = result.version);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    StormPackageManager.prototype.analyzenpm = function(content, firstime) {
      var curobject, entry, modules, result, _base, _results;
      modules = JSON.parse(content);
      _results = [];
      for (entry in modules.dependencies) {
        result = {
          name: entry,
          version: (_base = modules.dependencies[entry]).version != null ? _base.version : _base.version = "*",
          source: "builtin",
          type: "npm"
        };
        if (firstime) {
          this.npmPackages[entry] = result.version;
        } else {
          if (this.npmPackages[entry] == null) {
            this.emit("discovered", "npm", result);
          }
          this.npmPackages[result.name] = result.version;
        }
        if (typeof modules.dependencies[entry].dependencies === 'object') {
          curobject = modules.dependencies[entry].dependencies;
          _results.push((function() {
            var _base1, _results1;
            _results1 = [];
            for (content in curobject) {
              result = {
                name: content,
                version: (_base1 = curobject[content]).version != null ? _base1.version : _base1.version = "*",
                source: 'dependency',
                type: "npm"
              };
              if (firstime) {
                _results1.push(this.npmPackages[result.name] = result.version);
              } else {
                if (this.npmPackages[result.name] == null) {
                  this.emit("discovered", "npm", result);
                }
                _results1.push(this.npmPackages[result.name] = result.version);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    StormPackageManager.prototype.monitorNpmModules = function(callback) {
      this.log("Searching for NPM modules");
      return _discoverNpmModules((function(_this) {
        return function(stdout) {
          if (stdout == null) {
            return callback("success");
          }
          _this.analyzenpm(stdout, 0);
          return callback("success");
        };
      })(this));
    };

    StormPackageManager.prototype.monitor = function(repeatInterval) {
      if (repeatInterval == null) {
        repeatInterval = this.repeatInterval;
      }
      this.log("repeat Interval now is ", repeatInterval);
      return async.whilst((function(_this) {
        return function() {
          return true;
        };
      })(this), (function(_this) {
        return function(repeat) {
          async.waterfall([
            function(callback) {
              return _this.monitorNpmModules(function() {
                return callback();
              });
            }, function(callback) {
              return _this.monitorDebPkgs(function() {
                return callback();
              });
            }
          ], function(err, result) {});
          return setTimeout(repeat, repeatInterval);
        };
      })(this), (function(_this) {
        return function(err) {
          return _this.log('monitoring of packages stopped..');
        };
      })(this));
    };

    StormPackageManager.prototype.getCommand = function(installer, command, component, filename) {
      var append;
      this.log("Building command for " + installer + "." + command);
      append = component.version;
      if (component.version === "*") {
        append = "";
      }
      switch ("" + installer + "." + command) {
        case "dpkg.check":
          return "dpkg -l | grep -w \"" + component.name + " \" | grep -w \"" + append + " \"";
        case "npm.check":
          return "cd /lib; npm ls 2>/dev/null | grep \"" + component.name + "@" + append + "\"";
        case "npm.install":
          if (!filename) {
            return "npm install -g " + component.name + "@" + component.version;
          }
          return "npm install -g " + filename;
        case "dpkg.install":
          return "dpkg -i " + filename;
        case "apt-get.install":
          return "apt-get -y --force-yes install " + filename;
        case "dpkg.uninstall":
        case "apt-get.uninstall":
          return "dpkg -r " + filename;
        default:
          this.log(new Error("invalid command " + installer + "." + command + " for " + component.name + "!"));
          return null;
      }
    };

    StormPackageManager.prototype.check = function(installer, component, callback) {
      var command;
      this.log("checking if the component '" + component.name + "' has already been installed using " + installer + "...");
      switch (installer) {
        case "npm:":
          command = this.getCommand('npm', 'check', component);
          break;
        case "dpkg:":
        case "apt-get:":
          command = this.getCommand('dpkg', 'check', component);
          break;
        default:
          return callback(new Error("Unsupported installer " + installer));
      }
      return this.execute(command, (function(_this) {
        return function(error) {
          if (!(error instanceof Error)) {
            _this.log("" + component.name + " is already installed");
            return callback(true);
          } else {
            return callback(error);
          }
        };
      })(this));
    };

    StormPackageManager.prototype.execute = function(command, callback) {
      exec = require('child_process').exec;
      return exec("" + command, (function(_this) {
        return function(error, stdout, stderr) {
          _this.log("execution result for " + command + " ", error, stdout, stderr);
          if (error != null) {
            return callback(new Error(error));
          }
          return callback(stdout);
        };
      })(this));
    };

    StormPackageManager.prototype.install = function(pinfo, callback) {
      var parsedurl, url;
      if (!((pinfo.name != null) && (pinfo.version != null) && (pinfo.source != null))) {
        return new Error("Invalid parameters");
      }
      this.log("Installing package " + pinfo.name);
      url = require('url');
      if (pinfo.source != null) {
        parsedurl = url.parse(pinfo.source, true);
        this.log('the protocol for the package download is ', parsedurl.protocol);
      }
      return this.check(parsedurl.protocol, pinfo, (function(_this) {
        return function(pkg) {
          var append, cmd, err, filename, source, webreq;
          if (!(pkg instanceof Error)) {
            _this.log("Found the component installed ", pinfo.name);
            return callback(pinfo);
          }
          cmd = void 0;
          switch (parsedurl.protocol) {
            case 'npm:':
              if (parsedurl.path) {
                parsedurl.protocol = "http";
                filename = url.format(parsedurl);
                cmd = _this.getCommand("npm", "install", pinfo, filename);
              } else {
                cmd = _this.getCommand("npm", "install", pinfo);
              }
              pinfo.type = "npm";
              break;
            case "dpkg:":
              if (pinfo.source == null) {
                return callback(new Error("Must specify source"));
              }
              pinfo.type = "dpkg";
              parsedurl.protocol = "http";
              webreq = require('request');
              fs = require('fs');
              filename = "/tmp/" + pinfo.name + ".pkg";
              source = url.format(parsedurl);
              webreq(source, function(error, response, body) {
                if (error != null) {
                  return new Error("unable to download file");
                }
                if (fs.existsSync(filename)) {
                  cmd = _this.getCommand("dpkg", "install", pinfo, filename);
                  if (cmd == null) {
                    return callback(new Error("Unable to install package install"));
                  }
                  return _this.execute(cmd, function(result) {
                    if (result instanceof Error) {
                      return callback(new Error(result));
                    }
                    return callback(pinfo);
                  });
                } else {
                  return callback(new Error("unable to download package"));
                }
              }).pipe(fs.createWriteStream(filename));
              return;
            case "apt-get:":
              pinfo.type = "dpkg";
              append = "";
              if (pinfo.version !== "*") {
                append = "=" + pinfo.version;
              }
              cmd = _this.getCommand("apt-get", "install", pinfo, "" + pinfo.name + append);
              break;
            default:
              return callback(new Error("Unsupported package manager"));
          }
          try {
            return _this.execute(cmd, function(result) {
              if (result instanceof Error) {
                return callback(new Error(result));
              }
              return callback(pinfo);
            });
          } catch (_error) {
            err = _error;
            return callback(new Error("Failed to install"));
          }
        };
      })(this));
    };

    StormPackageManager.prototype.uninstall = function(pinfo, callback) {
      var cmd, parsedurl, url;
      if (pinfo.source === ("builtin" != null)) {
        return callback(new Error("Should not uninstall built in package"));
      }
      url = require('url');
      if (pinfo.source != null) {
        parsedurl = url.parse(pinfo.source, true);
        if (parsedurl == null) {
          return callback(new Error("Cannot parse the package source"));
        }
        switch (parsedurl.protocol) {
          case "npm:":
            cmd = this.getCommand("npm", "uninstall", pinfo);
            break;
          case "dpkg:":
          case "apt-get:":
            cmd = this.getCommand("dpkg", "uninstall", pinfo);
            break;
          default:
            return callback(new Error("Unsupported uninstall protocol"));
        }
        return this.execute(cmd, (function(_this) {
          return function(result) {
            if (result instanceof Error) {
              return callback(result);
            }
            return callback("Success");
          };
        })(this));
      }
    };

    return StormPackageManager;

  })(EventEmitter);

  module.exports = StormPackageManager;

}).call(this);
