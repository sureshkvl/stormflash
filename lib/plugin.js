// Generated by CoffeeScript 1.7.1
(function() {
  var StormPackage;

  StormPackage = require('./spm').StormPackage;

  this.include = function() {
    var agent, exec, fs, loadModule, validateModuleDesc;
    agent = this.settings.agent;
    this.post({
      '/packages': function() {
        return this.send(agent.install(new StormPackage(null, this.body)));
      }
    });
    this.get({
      '/packages': function() {
        return this.send(agent.packages.list());
      }
    });
    this.get({
      '/packages/:id': function() {
        var match;
        match = agent.tokens.get(this.params.id);
        if (match != null) {
          match.rule = agent.rules.get(match.data.ruleId);
          return this.send(match);
        } else {
          return this.send(404);
        }
      }
    });
    this.put({
      '/packages/:id': function() {
        return this.send(new Error("updating package currently not supported!"));

        /*
        match = agent.packages.get @params.id
        if match?
            @send agent.upgrade match, @body
        else
            @send 404
         */
      }
    });
    this.del({
      '/packages/:id': function() {
        var match;
        match = agent.packages.get(this.params.id);
        if (match != null) {
          return this.send(agent.remove(match));
        } else {
          return this.send(404);
        }
      }
    });
    fs = require('fs');
    exec = require('child_process').exec;
    this.get({
      '/plugins': function() {
        var res;
        res = agent.list();
        console.log(res);
        return this.send(res);
      }
    });
    validateModuleDesc = function() {
      var result;
      console.log(this.body);
      result = agent.validate(this.body);
      console.log(result);
      if (!result.valid) {
        return this.next(new Error("Invalid module posting!: " + result.errors));
      }
      return this.next();
    };
    loadModule = function() {
      var result;
      result = agent.lookup(this.params.id);
      if (!(result instanceof Error)) {
        this.request.module = result;
        return this.next();
      } else {
        return this.next(result);
      }
    };
    this.post('/plugins', validateModuleDesc, function() {
      var module;
      module = agent["new"](this.body);
      return agent.add(module, '', true, (function(_this) {
        return function(res) {
          if (!(res instanceof Error)) {
            if (res.status === 304) {
              return _this.send(304);
            } else {
              return _this.send(res);
            }
          } else {
            return _this.next(new Error("Invalid module posting! " + res));
          }
        };
      })(this));
    });
    this.get('/plugins/:id', loadModule, function() {
      var installed, module, status;
      module = this.request.module;
      installed = null;
      if (module.status) {
        installed = true;
      }
      status = {
        installed: installed != null ? installed : false,
        initialized: false,
        running: false,
        result: 'unknown'
      };
      return exec("monit summary | grep " + module.description.name, (function(_this) {
        return function(error, stdout, stderr) {
          console.log('stdout : ' + stdout);
          if (error || stderr) {
            status.result = '' + error;
          } else {
            if (stdout.match(/start pending/)) {
              status.initialized = true;
            } else if (stdout.match(/Running/)) {
              if (!stdout.match(/stop pending/)) {
                status.initialized = true;
                status.running = true;
              }
            }
            status.result = stdout;
          }
          module.status = status;
          console.log(module);
          return _this.send(module);
        };
      })(this));
    });
    this.put('/plugins/:id', validateModuleDesc, loadModule, function() {
      var module;
      module = agent["new"](this.body, this.params.id);
      return agent.update(module, this.request.module, (function(_this) {
        return function(res) {
          if (!(res instanceof Error)) {
            if (res.status === 304) {
              return _this.send(304);
            } else {
              return _this.send(res);
            }
          } else {
            return _this.next(new Error("Invalid module posting! " + res));
          }
        };
      })(this));
    });
    this.del('/plugins/:id', loadModule, function() {
      return agent.remove(this.request.module, (function(_this) {
        return function(res) {
          if (!(res instanceof Error)) {
            if (res.result === 304) {
              return _this.send(304);
            } else {
              return _this.send({
                deleted: true
              });
            }
          } else {
            return _this.next(res);
          }
        };
      })(this));
    });
    this.post('/plugins/:id/action', loadModule, function() {
      var desc, module;
      if (!this.body.command) {
        return this.next(new Error("Invalid module posting!"));
      }
      module = this.request.module;
      desc = module.description;
      console.log("looking to issue 'monit " + this.body.command + " " + desc.name + "'");
      switch (this.body.command) {
        case "start":
        case "stop":
        case "restart":
          return exec("monit " + this.body.command + " " + desc.name, (function(_this) {
            return function(error, stdout, stderr) {
              if (error) {
                return _this.next(new Error("Unable to perform requested action!"));
              }
              return _this.send({
                result: true
              });
            };
          })(this));
        default:
          return this.next(new Error("Invalid action, must specify 'command' (start|stop,restart)!"));
      }
    });
    return this.get('/getmodules', function() {
      var module, nodeModules, pattern, regex, res, _i, _len;
      res = [];
      nodeModules = fs.readdirSync("/lib/node_modules");
      pattern = "^stormflash";
      regex = new RegExp(pattern);
      for (_i = 0, _len = nodeModules.length; _i < _len; _i++) {
        module = nodeModules[_i];
        if (regex.test(module)) {
          console.log('module: ' + module);
          res.push(module);
        }
      }
      return this.send(res);
    });
  };

}).call(this);
