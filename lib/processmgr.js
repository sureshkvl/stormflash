// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, ProcessManager, ptrace, spawn,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ptrace = require('process-trace');

  spawn = require('child_process').spawn;

  EventEmitter = require('events').EventEmitter;

  ProcessManager = (function(_super) {
    var _defaultMonitorInterval, _defaultSpawnOptions;

    __extends(ProcessManager, _super);

    _defaultMonitorInterval = 10;

    _defaultSpawnOptions = {
      customFds: [-1, -1, -1],
      detached: true
    };

    function ProcessManager(context) {
      var detachCb, signalCb;
      ProcessManager.__super__.constructor.apply(this, arguments);
      if (context != null) {
        this.monitorInterval = context.monitorInterval;
        this.retries = context.retries;
        this.options = context.options;
        this.log = context.log;
      }
      if (this.monitorInterval == null) {
        this.monitorInterval = _defaultMonitorInterval;
      }
      if (this.options == null) {
        this.options = _defaultSpawnOptions;
      }
      if (this.log == null) {
        this.log = console.log;
      }
      this.log("Monitor interval is ", this.monitorInterval, " options for spawn are ", this.options);
      if (this.retries == null) {
        this.retries = 5;
      }
      detachCb = (function(_this) {
        return function(err, pid, key, result) {
          if (err && key !== void 0) {
            _this.log("detached from the process with pid " + pid);
            _this.emit("detached", result, pid, key);
            result = ptrace.sendsignal(pid, 2);
            return _this.log("sending signal to process with pid " + pid + " with result " + result);
          } else {
            _this.log("failed to detach from the process with pid " + pid);
            return _this.emit("detachError", err, pid, key);
          }
        };
      })(this);
      signalCb = (function(_this) {
        return function(err, pid, key, signal) {
          _this.log("Signal recieved with err " + err + " pid " + pid + " key " + key + " and signal " + signal);
          if (err !== null && signal === null) {
            _this.log("Unexpected error");
            _this.emit("error", signal, pid, key);
          }
          switch (signal) {
            case "exited":
            case "killed":
            case "stopped":
              return _this.emit("signal", signal, pid, key);
          }
        };
      })(this);
      this.dCbPtr = ptrace.getcbptr(detachCb);
      this.sCbPtr = ptrace.getcbptr(signalCb);
    }

    ProcessManager.prototype.setMonitorInterval = function(interval) {
      return this.monitorInterval = interval;
    };

    ProcessManager.prototype.start = function(binary, path, args, options, key) {
      var child;
      if (options == null) {
        options = this.options;
      }
      this.log("starting the process " + path + "/" + binary + " with args ", args, "and options ", options);
      child = spawn(("" + path) + ("/" + binary), args, options);
      child.unref();

      /*
      child.on "error", (err) =>
          @log "Error in starting the process. Reason is ", err
          @emit "error", err, child.pid, key
      
      child.on "exit", (code, signal) =>
          @log "Process Exit. Reason is ", code, signal
          if code isnt 0
              @emit "signal", "stopped" , child.pid,key
          else
              ptrace.sendsignal child.pid, 1
       */
      this.log("Process started with pid " + child.pid);
      return child.pid;
    };

    ProcessManager.prototype.stop = function(pid, key) {
      this.detach(pid, key);
    };

    ProcessManager.prototype.attach = function(pid, key) {
      var attachCb;
      attachCb = (function(_this) {
        return function(err, pid, key, result) {
          _this.log("type of result is ", typeof result);
          _this.log("Response to attach ", err, pid, key, result);
          if (err === null) {
            return _this.emit("attached", result, pid, key);
          } else {
            return _this.emit("attachError", err, pid, key);
          }
        };
      })(this);
      this.aCbPtr = ptrace.getcbptr(attachCb);
      return ptrace.add(pid, key, this.retries, this.aCbPtr);
    };

    ProcessManager.prototype.detach = function(pid, key) {
      return ptrace.detach(pid, key, this.retries, this.dCbPtr);
    };

    ProcessManager.prototype.monitor = function(pid, key) {
      var getsignal;
      getsignal = (function(_this) {
        return function() {
          return ptrace.getsignal.async(pid, key, _this.sCbPtr, function() {});
        };
      })(this);
      return setTimeout(getsignal, this.monitorInterval);
    };

    return ProcessManager;

  })(EventEmitter);

  module.exports = ProcessManager;

}).call(this);
