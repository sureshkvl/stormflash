// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, ProcessManager, async, ptrace, spawn,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ptrace = require('process-trace');

  spawn = require('child_process').spawn;

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  ProcessManager = (function(_super) {
    var _defaultMonitorInterval, _defaultSpawnOptions;

    __extends(ProcessManager, _super);

    _defaultMonitorInterval = 10;

    _defaultSpawnOptions = {
      customFds: [-1, -1, -1],
      detached: true
    };

    function ProcessManager(context) {
      var detachCb, signalCb;
      ProcessManager.__super__.constructor.apply(this, arguments);
      if (context != null) {
        this.monitorInterval = context.monitorInterval;
        this.retries = context.retries;
        this.options = context.options;
        this.log = context.log;
      }
      if (this.monitorInterval == null) {
        this.monitorInterval = _defaultMonitorInterval;
      }
      if (this.options == null) {
        this.options = _defaultSpawnOptions;
      }
      if (this.log == null) {
        this.log = console.log;
      }
      this.log("Monitor interval is ", this.monitorInterval, " options for spawn are ", this.options);
      if (this.retries == null) {
        this.retries = 5;
      }
      detachCb = (function(_this) {
        return function(err, pid, key, result) {
          if (err && key !== void 0) {
            _this.log("detached from the process with pid " + pid);
            _this.emit("detached", result, pid, key);
            result = ptrace.sendsignal(pid, 9);
            return _this.log("sending signal to process with pid " + pid + " with result " + result);
          } else {
            _this.log("failed to detach from the process with pid " + pid);
            return _this.emit("detachError", err, pid, key);
          }
        };
      })(this);
      signalCb = (function(_this) {
        return function(err, pid, key, signal) {
          _this.log("Signal recieved with err " + err + " pid " + pid + " key " + key + " and signal " + signal);
          if (err !== null && signal === null) {
            _this.log("Unexpected error");
            _this.emit("error", signal, pid, key);
          }
          switch (signal) {
            case "exited":
            case "killed":
            case "stopped":
              return _this.emit("signal", signal, pid, key);
          }
        };
      })(this);
      this.dCbPtr = ptrace.getcbptr(detachCb);
      this.sCbPtr = ptrace.getcbptr(signalCb);
    }

    ProcessManager.prototype.waitpid = function(pid, opts, callback) {
      var counter, interval, test, timeout, _ref, _ref1;
      if (!((pid != null) && (opts != null) && (opts.test != null))) {
        callback(new Error("must pass in proper options for waitpid!"));
      }
      test = opts.test;
      timeout = (_ref = opts.timeout) != null ? _ref : 0;
      interval = (_ref1 = opts.interval) != null ? _ref1 : 100;
      counter = 0;
      return async.until(function() {
        var err;
        try {
          process.kill(pid, 0);
          return test;
        } catch (_error) {
          err = _error;
          return !test;
        }
      }, function(wait) {
        if ((counter * interval) > timeout) {
          throw new Error("timeout reached while waiting on PID");
        }
        counter++;
        return setTimeout(wait, interval);
      }, function(err) {
        return callback(err, counter * interval);
      });
    };

    ProcessManager.prototype.setMonitorInterval = function(interval) {
      return this.monitorInterval = interval;
    };

    ProcessManager.prototype.start = function(binary, path, args, options, key) {
      var child;
      if (options == null) {
        options = this.options;
      }
      this.log("starting the process " + path + "/" + binary + " with args ", args, "and options ", options);
      child = spawn(("" + path) + ("/" + binary), args, options);
      child.unref();
      child.once("error", (function(_this) {
        return function(err) {
          _this.log("Error in starting the process. Reason is ", err);
          return _this.emit("error", err, child.pid, key);
        };
      })(this));

      /*
      child.on "exit", (code, signal) =>
          @log "Process Exit. Reason is ", code, signal
          if code isnt 0
              @emit "signal", "stopped" , child.pid,key
          else
              ptrace.sendsignal child.pid, 1
       */
      this.log("Process started with pid " + child.pid);
      return child.pid;
    };

    ProcessManager.prototype.stop = function(pid, key) {
      this.detach(pid, key);
    };

    ProcessManager.prototype.attach = function(pid, key) {
      var attachCb;
      attachCb = (function(_this) {
        return function(err, pid, key, result) {
          _this.log("type of result is ", typeof result);
          _this.log("Response to attach ", err, pid, key, result);
          if (err === null) {
            return _this.emit("attached", result, pid, key);
          } else {
            return _this.emit("attachError", err, pid, key);
          }
        };
      })(this);
      this.aCbPtr = ptrace.getcbptr(attachCb);
      return ptrace.add(pid, key, this.retries, this.aCbPtr);
    };

    ProcessManager.prototype.detach = function(pid, key) {
      return ptrace.detach(pid, key, this.retries, this.dCbPtr);
    };

    ProcessManager.prototype.monitor = function(pid, key) {
      var getsignal;
      getsignal = (function(_this) {
        return function() {
          return ptrace.getsignal.async(pid, key, _this.sCbPtr, function() {});
        };
      })(this);
      return setTimeout(getsignal, this.monitorInterval);
    };

    return ProcessManager;

  })(EventEmitter);

  module.exports = ProcessManager;

}).call(this);
