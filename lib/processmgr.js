// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, ProcessManager, async, ptrace, spawn,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ptrace = require('process-trace');

  spawn = require('child_process').spawn;

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  ProcessManager = (function(_super) {
    var _defaultMonitorInterval, _defaultSpawnOptions;

    __extends(ProcessManager, _super);

    _defaultMonitorInterval = 5;

    _defaultSpawnOptions = {
      customFds: [-1, -1, -1],
      detached: true
    };

    function ProcessManager(context) {
      var detachCb, signalCb;
      ProcessManager.__super__.constructor.apply(this, arguments);
      if (context != null) {
        this.monitorInterval = context.monitorInterval;
        this.retries = context.retries;
        this.options = context.options;
        this.log = context.log;
      }
      if (this.monitorInterval == null) {
        this.monitorInterval = _defaultMonitorInterval;
      }
      if (this.options == null) {
        this.options = _defaultSpawnOptions;
      }
      if (this.log == null) {
        this.log = console.log;
      }
      this.log("Monitor interval is ", this.monitorInterval, " options for spawn are ", this.options);
      if (this.retries == null) {
        this.retries = 5;
      }
      detachCb = (function(_this) {
        return function(err, pid, key, result) {
          _this.log("Entering detach callback for the process with pid " + pid + ", key " + key + ", Error : ", err);
          if (err === null && key !== void 0) {
            _this.log("detached from the process with pid " + pid);
            _this.emit("detached", result, pid, key);
            return _this.log("sending signal to process with pid " + pid + " with result " + result);
          } else {
            _this.log("failed to detach from the process with pid " + pid);
            return _this.emit("detachError", err, pid, key);
          }
        };
      })(this);
      signalCb = (function(_this) {
        return function(err, pid, key, signal, signum) {
          _this.log("Signal recieved with err " + err + " pid " + pid + " key " + key + " and signal " + signal);
          if (err !== null && signal === null) {
            _this.log("Unexpected error");
            _this.emit("error", signal, pid, key);
          }
          switch (signal) {
            case "exited":
            case "killed":
            case "stopped":
              return _this.emit("signal", signal, signum, pid, key);
          }
        };
      })(this);
      this.dCbPtr = ptrace.getcbptr(detachCb);
      this.sCbPtr = ptrace.getcbptr(signalCb);
    }

    ProcessManager.prototype.setMonitorInterval = function(interval) {
      return this.monitorInterval = interval;
    };

    ProcessManager.prototype.mapSignals = function(signal) {
      var signum;
      this.log("Signal: ", signal);
      signum = '';
      switch (signal) {
        case "SIGHUP":
          signum = 1;
          break;
        case "SIGINT":
          signum = 2;
          break;
        case "SIGQUIT":
          signum = 3;
          break;
        case "SIGILL":
          signum = 4;
          break;
        case "SIGTRAP":
          signum = 5;
          break;
        case "SIGABRT":
          signum = 6;
          break;
        case "SIGBUS":
          signum = 7;
          break;
        case "SIGFPE":
          signum = 8;
          break;
        case "SIGKILL":
          signum = 9;
          break;
        case "SIGUSR1":
          signum = 10;
          break;
        case "SIGSEGV":
          signum = 11;
          break;
        case "SIGUSR2":
          signum = 12;
          break;
        case "SIGPIPE":
          signum = 13;
          break;
        case "SIGALRM":
          signum = 14;
          break;
        case "SIGTERM":
          signum = 15;
          break;
        case "SIGSTKFLT":
          signum = 16;
          break;
        case "SIGCHLD":
          signum = 17;
          break;
        case "SIGCONT":
          signum = 18;
          break;
        case "SIGSTOP":
          signum = 19;
          break;
        case "SIGTSTP":
          signum = 20;
          break;
        case "SIGTTIN":
          signum = 21;
          break;
        case "SIGTTOU":
          signum = 22;
          break;
        case "SIGURG":
          signum = 23;
          break;
        case "SIGXCPU":
          signum = 24;
          break;
        case "SIGXFSZ":
          signum = 25;
          break;
        case "SIGVTALRM":
          signum = 26;
          break;
        case "SIGPROF":
          signum = 27;
          break;
        case "SIGWINCH":
          signum = 28;
          break;
        case "SIGIO":
          signum = 29;
          break;
        case "SIGPWR":
          signum = 30;
          break;
        case "SIGSYS":
          signum = 31;
          break;
        default:
          signum = -1;
      }
      return signum;
    };

    ProcessManager.prototype.start = function(binary, path, args, options, key) {
      var child;
      if (options == null) {
        options = this.options;
      }
      this.log("starting the process " + path + "/" + binary + " with args ", args, "and options ", options);
      child = spawn(("" + path) + ("/" + binary), args, options);
      child.unref();
      child.on("error", (function(_this) {
        return function(err) {
          _this.log("Error in starting the process. Reason is ", err);
          return _this.emit("error", err, child.pid, key);
        };
      })(this));
      child.on("exit", (function(_this) {
        return function(code, signal) {
          var signum;
          signum = '';
          _this.log("Process Exit. Reason is ", code, signal);
          _this.log("going to call mapSignals");
          signum = _this.mapSignals(signal);
          _this.log("SISISISIS. signal details ", signal, signum);
          switch (signum) {
            case 11:
            case 13:
              _this.log("Emitting signals with " + signum);
              return _this.emit("signal", "stopped", signum, child.pid, key);
          }
        };
      })(this));
      this.log("Process started with pid " + child.pid);
      return child.pid;
    };

    ProcessManager.prototype.stop = function(signum, pid, key) {
      this.detach(signum, pid, key);
    };

    ProcessManager.prototype.attach = function(pid, key) {
      var attachCb;
      attachCb = (function(_this) {
        return function(err, pid, key, result) {
          _this.log("type of result is ", typeof result);
          _this.log("Response to attach ", err, pid, key, result);
          if (err === null) {
            return _this.emit("attached", result, pid, key);
          } else {
            return _this.emit("attachError", err, pid, key);
          }
        };
      })(this);
      this.aCbPtr = ptrace.getcbptr(attachCb);
      return ptrace.add(pid, key, this.retries, this.aCbPtr);
    };

    ProcessManager.prototype.detach = function(signum, pid, key) {
      this.log("inside detach", pid);
      this.once('detached', (function(_this) {
        return function(result, key, pid) {
          return ptrace.sendsignal(pid, signum);
        };
      })(this));
      return ptrace.detach(pid, key, this.retries, this.dCbPtr);
    };

    ProcessManager.prototype.monitor = function(pid, key) {
      var getsignal;
      getsignal = (function(_this) {
        return function() {
          return ptrace.getsignal.async(pid, key, _this.sCbPtr, function() {});
        };
      })(this);
      return setTimeout(getsignal, this.monitorInterval);
    };

    return ProcessManager;

  })(EventEmitter);

  module.exports = ProcessManager;

}).call(this);
