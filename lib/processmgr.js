// Generated by CoffeeScript 1.6.1
(function() {
  var EventEmitter, ProcessManager, ptrace, spawn,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ptrace = require('process-trace');

  spawn = require('child_process').spawn;

  EventEmitter = require('events').EventEmitter;

  ProcessManager = (function(_super) {
    var _defaultMonitorInterval, _defaultSpawnOptions;

    __extends(ProcessManager, _super);

    _defaultMonitorInterval = 10;

    _defaultSpawnOptions = {
      customFds: [-1, -1, -1],
      detached: true
    };

    function ProcessManager(monitorInterval, retries, options) {
      var detachCb, signalCb,
        _this = this;
      this.monitorInterval = monitorInterval;
      this.retries = retries;
      this.options = options;
      ProcessManager.__super__.constructor.apply(this, arguments);
      if (this.monitorInterval == null) {
        this.monitorInterval = _defaultMonitorInterval;
      }
      if (this.options == null) {
        this.options = _defaultSpawnOptions;
      }
      console.log("Monitor interval is ", this.monitorInterval, " options for spawn are ", this.options);
      if (this.retries === void 0) {
        this.retries = 5;
      }
      detachCb = function(err, pid, key, result) {
        if (err && key !== void 0) {
          console.log("detached from the process with pid " + pid);
          _this.emit("detached", result, pid, key);
          result = ptrace.sendsignal(pid, 2);
          return console.log("sending signal to process with pid " + pid + " with result " + result);
        } else {
          console.log("failed to detach from the process with pid " + pid);
          return _this.emit("detachError", err, pid, key);
        }
      };
      signalCb = function(err, pid, key, signal) {
        console.log("Signal recieved with err " + err + " pid " + pid + " key " + key + " and signal " + signal);
        if (err !== null && signal === null) {
          console.log("Unexpected error");
          _this.emit("stopped", signal, pid, key);
        }
        switch (signal) {
          case "exited":
          case "killed":
          case "stopped":
            return _this.emit("signal", signal, pid, key);
        }
      };
      this.dCbPtr = ptrace.getcbptr(detachCb);
      this.sCbPtr = ptrace.getcbptr(signalCb);
    }

    ProcessManager.prototype.setMonitorInterval = function(interval) {
      return this.monitorInterval = interval;
    };

    ProcessManager.prototype.start = function(binary, path, args, key) {
      var child;
      console.log("starting the process " + path + "/" + binary + " with args ", args, "and options ", this.options);
      child = spawn(("" + path) + ("/" + binary), args, this.options);
      child.unref();
      /*
      child.on "error", (err) =>
          console.log "Error in starting the process. Reason is ", err
          @emit "error", err, child.pid, key
      
      child.on "exit", (code, signal) =>
          console.log "Process Exit. Reason is ", code, signal
          if code isnt 0
              @emit "signal", "stopped" , child.pid,key
          else
              ptrace.sendsignal child.pid, 1
      */

      console.log("Process started with pid " + child.pid);
      return child.pid;
    };

    ProcessManager.prototype.stop = function(pid, key) {
      this.detach(pid, key);
    };

    ProcessManager.prototype.attach = function(pid, key) {
      var attachCb,
        _this = this;
      attachCb = function(err, pid, key, result) {
        console.log("type of result is ", typeof result);
        console.log("Response to attach ", err, pid, key, result);
        if (err === null) {
          return _this.emit("attached", result, pid, key);
        } else {
          return _this.emit("attachError", err, pid, key);
        }
      };
      this.aCbPtr = ptrace.getcbptr(attachCb);
      return ptrace.add(pid, key, this.retries, this.aCbPtr);
    };

    ProcessManager.prototype.detach = function(pid, key) {
      return ptrace.detach(pid, key, this.retries, this.dCbPtr);
    };

    ProcessManager.prototype.monitor = function(pid, key) {
      return ptrace.getsignal.async(pid, key, this.sCbPtr, function(result) {});
    };

    return ProcessManager;

  })(EventEmitter);

  module.exports.ProcessManager = ProcessManager;

}).call(this);
