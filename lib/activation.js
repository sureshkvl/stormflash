// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, activation, boltConfigfile, filename, fileops, fs, openssl, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('util');

  EventEmitter = require('events').EventEmitter;

  filename = "/etc/bolt/bolt.json";

  fileops = require('fileops');

  openssl = require('openssl-wrapper');

  fs = require('fs');

  boltConfigfile = '/etc/stormstack/stormbolt.conf';

  activation = (function(_super) {
    __extends(activation, _super);

    function activation(config) {
      this.config = config;
      this.start = __bind(this.start, this);
      this.isItActivated = __bind(this.isItActivated, this);
      this.sendCSRRequest = __bind(this.sendCSRRequest, this);
      this.getCSRData = __bind(this.getCSRData, this);
      this.connect = __bind(this.connect, this);
      this.discoverEnv = __bind(this.discoverEnv, this);
      this.isitSOFTCPE = __bind(this.isitSOFTCPE, this);
      this.isitHARDCPE = __bind(this.isitHARDCPE, this);
      this.isitVCG = __bind(this.isitVCG, this);
      util.log("activation constructor called with " + JSON.stringify(this.config));
      this.keyfile = "" + this.config.datadir + "/certs/snap.key";
      this.csrfile = "" + this.config.datadir + "/certs/snap.csr";
      this.certfile = "" + this.config.datadir + "/certs/snap.cert";
      this.cafile = "" + this.config.datadir + "/certs/ca.cert";
      this.metadatafile = "" + this.config.datadir + "/certs/meta-data.json";
      this.STORMTRACKER_URL = null;
      this.REGKEY = null;
      this.HOSTNAME = null;
      this.OPENSTACK_URL = 'http://192.168.122.248/latest/meta-data';
      this.boltdata = null;
      util.log("activation constructor called");
    }

    activation.prototype.isitVCG = function(callback) {
      var req;
      util.log("inside isitVCG function" + this.OPENSTACK_URL);
      req = http.get(this.OPENSTACK_URL, (function(_this) {
        return function(res) {
          console.log("openstack metadata http response statusCode: " + res.statusCode);
          res.on('data', function(chunk) {
            var metadata;
            metadata = JSON.parse(chunk.toString());
            util.log("Metadata " + metadata);
            if (!((metadata.meta.nexusurl != null) || (metadata.uuid != null))) {
              callback(false);
            }
            _this.STORMTRACKER_URL = metadata.meta.nexusUrl;
            _this.REGKEY = metadata.uuid;
            util.log("StormTracker Url " + _this.STORMTRACKER_URL);
            util.log("uuidi " + _this.REGKEY);
            return fileops.updateFile(_this.metadatafile, JSON.stringify(metadata));
          });
          return res.on('end', function(x) {
            console.log('openstack metadata connection end', x);
            return callback(true);
          });
        };
      })(this));
      return req.on('error', (function(_this) {
        return function(data) {
          util.log('Error in the openstack metadata http request: ' + data.message);
          return callback(false);
        };
      })(this));
    };

    activation.prototype.isitHARDCPE = function() {
      return false;
    };

    activation.prototype.isitSOFTCPE = function() {
      return false;
    };

    activation.prototype.discoverEnv = function(callback) {
      util.log("inside discoverEnv function");
      return this.isitVCG((function(_this) {
        return function(res) {
          util.log("isitvcg response is " + res);
          if (res === true) {
            _this.ENVIRONMENT = 'VCG';
            return callback(true);
          }
        };
      })(this));

      /*
      else if isitHARDCPE() is true
          @ENVIRONMENT="HARDCPE"
          callback(true)
      else if isitSOFTCPE() is true
          @ENVIRONMENT="SOFTCPE"
          callback(true)
      else
           *unknown environment
          @ENVIRONMENT="UNKNOWN"
          callback(false)
       */
    };

    activation.prototype.connect = function(callback) {
      var process, spawn;
      util.log("connect inside");
      spawn = require('child_process').spawn;
      process = spawn('/bin/ping', ['-c', '1', this.STORMTRACKER_URL]);
      process.stdout.on('data', (function(_this) {
        return function(data) {
          var array, lines, status;
          util.log("ping data " + data);
          lines = data.toString().split('\n');
          array = lines[1].split(' ');
          util.log("Ping output " + array);
          if (!array[4] || array[1].indexOf('Unreachable') > -1) {
            status = false;
          } else {
            status = true;
          }
          util.log("connect status " + status);
          return callback(status);
        };
      })(this));
      process.on('error', (function(_this) {
        return function(data) {
          util.log("Ping error" + data);
          return callback(false);
        };
      })(this));
      return process.stderr.on('data', (function(_this) {
        return function(data) {
          util.log("Ping error " + data);
          return callback(false);
        };
      })(this));
    };

    activation.prototype.register = function(callback) {
      var options, req;
      options = {
        host: this.STORMTRACKER_URL,
        port: 80,
        path: '/registry/serialkey',
        headers: {
          method: 'GET'
        }
      };
      req = http.request(options, (function(_this) {
        return function(res) {
          util.log('Activation - Register: response status code' + res.statusCode);
          util.log('Activation - Register: response status headers' + JSON.stringify(res.headers));
          return res.on('data', function(chunk) {
            var contents, metadata;
            metadata = JSON.parse(chunk.toString());
            util.log("Activation - Register: response data" + chunk.toString());
            _this.HOSTNAME = metadata.serialkey;
            util.log("Activation - Register : serialkey is " + _this.HOSTNAME);
            fs.writeFileSync("/etc/hostname", _this.HOSTNAME);
            contents = '';
            contents = new Buffer(metadata.stormbolt.cabundle.data || '', metadata.stormbolt.cabundle.encoding);
            util.log("Activation - Register : writing the cabundle " + _this.cafile);
            fs.writeFileSync(_this.cafile, contents);
            _this.boltdata = {
              "cert": _this.certfile,
              "key": _this.keyfile,
              "ca": _this.cafile,
              "remote": metadata.stormbolt.servers,
              "listen": metadata.stormbolt.proxy_listen_port,
              "local": metadata.stormbolt.server_port,
              "local_forwarding_ports": metadata.stormbolt.local_forwarding_ports,
              "beaconParams": "" + metadata.stormbolt.beacon.interval + ":" + metadata.stormbolt.beacon.retry
            };
            util.log(JSON.stringify(_this.boltdata));
            return callback(true);
          });
        };
      })(this));
      req.on('error', (function(_this) {
        return function(err) {
          util.log('http request error ', err);
          return callback(false);
        };
      })(this));
      return req.end();
    };

    activation.prototype.getCSRData = function() {
      var csrdata;
      csrdata = {
        "name": "client1",
        "encoding": "base64",
        "data": ""
      };
      csrdata.data = fs.readFileSync(this.csrfile, 'base64');
      csrdata.name = this.HOSTNAME;
      console.log("in getCSRData");
      return csrdata;
    };

    activation.prototype.sendCSRRequest = function(callback) {
      return openssl.exec('genrsa', {
        out: this.keyfile,
        '2048': false
      }, (function(_this) {
        return function(x) {
          util.log("Activation: openssl private key generation completed, result " + x);
          return openssl.exec('req', {
            batch: true,
            "new": true,
            nodes: true,
            subj: '/emailAddress=certs@clearpathnet.com/C=US/ST=CA/L=El Segundo/O=ClearPath Networks/OU=VSP/CN=' + _this.HOSTNAME,
            key: _this.keyfile,
            out: _this.csrfile
          }, function(x) {
            var csrjson, options1, req1;
            util.log("Activation: openssl csr generation completed , result", x);
            csrjson = _this.getCSRData();
            util.log("Activation: successfully created the CSR Requests for signing ", csrjson);
            options1 = {
              host: _this.STORMTRACKER_URL,
              port: 80,
              path: '/signcsr',
              method: 'POST',
              headers: {
                'Content-Type': 'application/json; charset=utf-8',
                'Accept': 'application/json',
                'Accept-Encoding': 'gzip,deflate,sdch',
                'Accept-Language': 'en-US,en;q=0.8'
              }
            };
            req1 = http.request(options1, function(res) {
              util.log('Activation: sendCSRRequest: response status code ' + res.statusCode);
              util.log('Activation: sendCSRRequest: response status headers', +JSON.stringify(res.headers));
              return res.on('data', function(chunk) {
                var contents, metadata;
                metadata = JSON.parse(chunk.toString());
                util.log("Activation: CSR response data" + chunk.toString());
                contents = '';
                contents = new Buffer(metadata.data || '', metadata.encoding);
                util.log("Activation: writing the signed certificate " + _this.certfile);
                fs.writeFileSync(_this.certfile, contents);
                return callback(true);
              });
            });
            req1.on('error', function(err) {
              util.log('Activation : sendCSRRequest http req error', err);
              return callback(false);
            });
            req1.write(JSON.stringify(csrjson));
            return req1.end();
          });
        };
      })(this));
    };

    activation.prototype.isItActivated = function() {
      return false;
    };

    activation.prototype.start = function() {
      var activate, activated, boltContent, result;
      util.log("activation start function called " + JSON.stringify(this.config));
      result = this.isItActivated();
      if (result === true) {
        util.log("its already activated...");
        boltContent = fileops.readFileSync(boltConfigfile);
        this.boltconfig = JSON.parse(boltContent);
        this.emit("success", this.boltconfig);
        return;
      }
      activated = false;
      activate = function(callback) {
        return async.waterfall([
          function(next) {
            return env.discover(function(stormdata) {
              if (stormdata != null) {
                return next(null, stormdata);
              } else {
                return next(new Error("unable to discover environment!"));
              }
            });
          }, function(stormdata, next) {
            return this.register(function(result) {
              if (result) {
                return next(null, result);
              } else {
                return next(new Error("unable to register against stormtracker at " + stormdata.stormtracker + "!"));
              }
            });
          }, function(result, next) {
            return this.sendCSRRequest(function(result) {
              if (result) {
                return next(null);
              }
            });
          }
        ], function(err, result) {
          if (result) {
            try {
              boltContent = fileops.readFileSync(boltConfigfile);
              this.boltconfig = JSON.parse(boltContent);
            } catch (_error) {
              this.boltconfig = this.boltdata;
              fileops.updateFile(boltConfigfile, JSON.stringify(this.boltconfig));
            } finally {
              this.emit("success", this.boltconfig);
            }
          }
          return callback(err, result);
        });
      };
      async.until(function() {
        return activated != null;
      }, function(repeat) {
        return activate(function(err, res) {
          if (res) {
            activated = true;
            return repeat;
          } else {
            util.log("error during activation: " + err);
            return setInterval(repeat, 5000);
          }
        });
      }, function(err) {});
      return this.discoverEnv((function(_this) {
        return function(result) {
          util.log("Activation Environment is " + _this.ENVIRONMENT);
          util.log("Activation discoverEnv result" + result);
          if (result === false) {
            _this.emit("failure", "Unknown Environment");
            return;
          }
          return _this.connect(function(result) {
            util.log(" Activation: connectivity to stormtracker, result is " + result);
            if (result === false) {
              _this.emit("failure", "Failed to Connect the STORMTRACKER");
              return result;
            }
            return _this.register(function(result) {
              util.log("Activation: Registeration completed. result " + result);
              if (result === false) {
                _this.emit("failure", "Failed to Register with  STORMTRACKER");
                return result;
              }
              return _this.sendCSRRequest(function(result) {
                util.log("CSR signing process over. result " + result);
                if (result === false) {
                  _this.emit("failure", "Failed to Get the Signed certificate from STORMTRACKER");
                  return result;
                }
                try {
                  boltContent = fileops.readFileSync(boltConfigfile);
                  return _this.boltconfig = JSON.parse(boltContent);
                } catch (_error) {
                  _this.boltconfig = _this.boltdata;
                  return fileops.updateFile(boltConfigfile, JSON.stringify(_this.boltconfig));
                } finally {
                  _this.emit("success", _this.boltconfig);
                  return true;
                }
              });
            });
          });
        };
      })(this));
    };

    return activation;

  })(EventEmitter);

  module.exports = function(args) {
    return new activation(args);
  };

}).call(this);
